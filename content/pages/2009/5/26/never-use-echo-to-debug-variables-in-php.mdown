date: 26 May 2009 17:49pm
categories: PHP
read more: More&#8230;
summary: Great speed tweak on OS X.  You'll thank me later.

# Never Use Echo() to Debug Variables in PHP
 
It is a common mistake for developers to use the `echo()` function to output <abbr title="PHP: Hypertext Preprocessor">PHP</abbr> variables to a web page when debugging. `var_dump()` is the correct way to do it.  Here&#8217;s why.

I often witness developers using `echo()` to output variable values:

<pre>:::php
<?php
  echo($var);
?>
</pre>

...or perhaps either of these:

<pre>:::php
<?php
  echo('var: ' . $var . '<br />');
  echo("var: $var");
?>
</pre>

## Boolean Casting

The problem with using `echo()` to output non-Strings is that for PHP to send values to the browser, it must cast them to String first. PHP has a series of <a href="http://us.php.net/language.types.type-juggling">rules surrounding how types are cast</a> from one to the other.  Integers and Floats cast to Strings verbatim, so there is nothing to worry about there.  But, Booleans do not cast to String as one would expect.  When using `echo()`, `print()`, or even `print_r()`, you will not see a &#8220;True&#8221; or &#8220;False&#8221; output to the browser, or even a 1 or 0.  **A TRUE Boolean casts to a &#8216;1&#8217;, but a FALSE casts to Empty String!**  (This is intentional by the PHP developers for reasons I won&#8217;t get into here.)  You can see this in action:

<pre>:::php
<?php
  $var = TRUE;
  $var2 = FALSE;
  echo($var); // Outputs a 1.
  echo($var2); // Blank. Nothing outputs.
  print($var2); // Blank.
  print_r($var2); // Blank.
?>
</pre>

When we were learning PHP, many of us were naturally baffled by this output.  This is why I see many PHP developers using 1 and 0 integers, or worse &#8216;t&#8217; and &#8216;f&#8217; strings, instead of true Boolean values.  [Even worse, &#8220;True&#8221; and &#8220;False&#8221; in quotes.]  They were likely trying to echo some Booleans and where seeing 1&#8217;s for their True values and blanks for their False values, so they gave up and resorted to using Integers and Strings.  Integer and String comparisons are orders of magnitude slower than Boolean comparisons [especially Strings], so this is best avoided.

## Solution

### var_dump()

The `var_dump()` function exists for exactly this purpose&#8212;to show you the real, uncast values of all your types [vars, arrays, objects, etc.]  `var_dump()` will give you the genuine value of your Booleans and all other types for that matter:

<pre>:::php
<?php
  $var2 = FALSE;
  var_dump($var2);
?>
</pre>

Outputs:

<pre>:::php
  bool(false)
</pre>

What we&#8217;re seeing is the Type and its value in parentheses.  No more confusing blank output!

`var_dump()` has another indispensable benefit.  It also works great on Compound Types like Array and Object.  It shows you the **entire contents** of an array or object, and all of its members and their types, in one simple command.  This is very useful.

Always use `var_dump()` to debug your Types.  Do not use `echo()`, `print()`, or `print_r()` anymore.

## But I Never Had to Worry About Types in PHP and My Programs Still Work

Programmers who came up solely through dynamic languages often neglect learning about [typing systems](http://en.wikipedia.org/wiki/Type_system/), given that they have never had to explicitly declare a variable&#8217;s type.  [Out of sight, out of mind.]  This phenomenon is compounded by weakly typed dynamic languages like JavaScript, PHP, Perl, and VB Script where types are cast implicitly at runtime and type errors are almost nonexistent.  Because it is so easy to use variables as you please with no explicit type definitions or manual casting, it&#8217;s easy to be oblivious to what the typing systems are doing behind the scenes.   When you make a variable declaration such as `$a = 1`, PHP knows that variable is an Integer and secretly maintains a record of that fact until that variable is cast to a different type \[either implicitly or explicitly\].  If you add a numeric string value to the $a integer, >PHP casts that value to an Integer, then does the math correctly without throwing a runtime error.

<pre>:::php
<?php
  $a = 1;
  $b = '2';
  var_dump($a + $b);
?>
</pre>

Outputs:

<pre>:::php
  int(3)
</pre>

A strongly typed language, such as Python and Ruby, would throw a casting error with the above.  This is done for performance reasons.  A language that doesn&#8217;t need to implicitly cast variables repeatedly throughout a program at runtime is a language that is faster.  Think about what PHP had to do in the above example.  The expression contains a mathematical operator [+].  PHP can now assume that both operands must be Integers or Floats.  It checks the types of both sides of the expression [$a and $b].  \[Note that Python and Ruby would stop here with an error.\]  Upon determining that one operand is a non-integer, PHP must cast the other to an integer.  Now it must determine if the string is the type of thing that *can* be cast to an Integer.  It must first verify that it contains only numeric characters and an optional decimal point.  If so, it casts that value to integer.  If not, then it concatenates the two as strings, and concatenation is expensive.  One can see the added processing that must occur, when if the language let us know from the outset that we were attempting to use an addition operator between a numeric and non-numeric type, it would have saved this program from these added checks and casts.  It would have forced the programmer into better practices that would have kept their programs performing efficiently, like keeping your types matched.

It is critical to understand these interactions and to know when and why PHP is casting your types.  It&#8217;s also imperative to minimize PHP&#8217;s implicit type casting by keeping your types consistently matched \[keep Integers as Integers, Boolean as Booleans, and so on\].  By using `var_dump()` consistently, in time you will learn PHP&#8217;s type conversion rules, will better understand the PHP typing system, will learn to mitigate implicit casts, and therefore will be a more effective and efficient programmer!

Live by `var_dump()`!
